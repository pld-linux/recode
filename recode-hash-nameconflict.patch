diff -Nur recode-3.5d.orig/src/combine.c recode-3.5d/src/combine.c
--- recode-3.5d.orig/src/combine.c	Wed Jun 28 20:40:16 2000
+++ recode-3.5d/src/combine.c	Fri Mar 16 04:44:34 2001
@@ -91,7 +91,7 @@
   if (before_options || after_options)
     return false;
 
-  table = hash_initialize (0, NULL, combined_hash, combined_compare, NULL);
+  table = recode_hash_initialize (0, NULL, combined_hash, combined_compare, NULL);
 
   if (!table)
     return false;
@@ -103,7 +103,7 @@
 
   while (*data != DONE)
     {
-      if (!hash_insert (table, data))
+      if (!recode_hash_insert (table, data))
 	return false;
 
       while (*data != DONE)
@@ -127,7 +127,7 @@
   while (value = get_byte (subtask), value != EOF)
     {
       unsigned short lookup = value;
-      unsigned short *result = hash_lookup (table, &lookup);
+      unsigned short *result = recode_hash_lookup (table, &lookup);
 
       if (result)
 	{
@@ -154,7 +154,7 @@
   while (get_ucs2 (&value, subtask))
     {
       unsigned short lookup = value;
-      unsigned short *result = hash_lookup (table, &lookup);
+      unsigned short *result = recode_hash_lookup (table, &lookup);
 
       if (result)
 	{
@@ -186,7 +186,7 @@
       while (true)
 	{
 	  unsigned short lookup = value;
-	  unsigned short *result = hash_lookup (table, &lookup);
+	  unsigned short *result = recode_hash_lookup (table, &lookup);
 
 	  if (result)
 	    {
@@ -219,7 +219,7 @@
       while (true)
 	{
 	  unsigned short lookup = value;
-	  unsigned short *result = hash_lookup (table, &lookup);
+	  unsigned short *result = recode_hash_lookup (table, &lookup);
 
 	  if (result)
 	    {
@@ -310,7 +310,7 @@
       struct state lookup;
 
       lookup.character = character;
-      state = hash_lookup (table, &lookup);
+      state = recode_hash_lookup (table, &lookup);
       if (!state)
 	{
 	  if (state= (struct state *) malloc (sizeof (struct state)), !state)
@@ -322,7 +322,7 @@
 	  state->unshift = NULL;
 	  state->next = NULL;
 
-	  if (!hash_insert (table, state))
+	  if (!recode_hash_insert (table, state))
 	    return NULL;
 	}
       return state;
@@ -351,7 +351,7 @@
       struct state lookup;
 
       lookup.character = character;
-      return hash_lookup (table, &lookup);
+      return recode_hash_lookup (table, &lookup);
     }
 }
 
@@ -367,7 +367,7 @@
   if (before_options || after_options)
     return false;
 
-  table = hash_initialize (0, NULL, state_hash, state_compare, NULL);
+  table = recode_hash_initialize (0, NULL, state_hash, state_compare, NULL);
 
   if (!table)
     return false;
diff -Nur recode-3.5d.orig/src/hash.c recode-3.5d/src/hash.c
--- recode-3.5d.orig/src/hash.c	Mon Jan 10 01:24:59 2000
+++ recode-3.5d/src/hash.c	Fri Mar 16 04:44:34 2001
@@ -118,7 +118,7 @@
    the same quantity.  */
 
 unsigned
-hash_get_n_buckets (const Hash_table *table)
+recode_hash_get_n_buckets (const Hash_table *table)
 {
   return table->n_buckets;
 }
@@ -126,7 +126,7 @@
 /* Return the number of slots in use (non-empty buckets).  */
 
 unsigned
-hash_get_n_buckets_used (const Hash_table *table)
+recode_hash_get_n_buckets_used (const Hash_table *table)
 {
   return table->n_buckets_used;
 }
@@ -134,7 +134,7 @@
 /* Return the number of active entries.  */
 
 unsigned
-hash_get_n_entries (const Hash_table *table)
+recode_hash_get_n_entries (const Hash_table *table)
 {
   return table->n_entries;
 }
@@ -142,7 +142,7 @@
 /* Return the length of the longest chain (bucket).  */
 
 unsigned
-hash_get_max_bucket_length (const Hash_table *table)
+recode_hash_get_max_bucket_length (const Hash_table *table)
 {
   struct hash_entry *bucket;
   unsigned max_bucket_length = 0;
@@ -169,7 +169,7 @@
    statistics.  */
 
 bool
-hash_table_ok (const Hash_table *table)
+recode_hash_table_ok (const Hash_table *table)
 {
   struct hash_entry *bucket;
   unsigned n_buckets_used = 0;
@@ -198,12 +198,12 @@
 }
 
 void
-hash_print_statistics (const Hash_table *table, FILE *stream)
+recode_hash_print_statistics (const Hash_table *table, FILE *stream)
 {
-  unsigned n_entries = hash_get_n_entries (table);
-  unsigned n_buckets = hash_get_n_buckets (table);
-  unsigned n_buckets_used = hash_get_n_buckets_used (table);
-  unsigned max_bucket_length = hash_get_max_bucket_length (table);
+  unsigned n_entries = recode_hash_get_n_entries (table);
+  unsigned n_buckets = recode_hash_get_n_buckets (table);
+  unsigned n_buckets_used = recode_hash_get_n_buckets_used (table);
+  unsigned max_bucket_length = recode_hash_get_max_bucket_length (table);
 
   fprintf (stream, "# entries:         %u\n", n_entries);
   fprintf (stream, "# buckets:         %u\n", n_buckets);
@@ -216,7 +216,7 @@
    entry from the table.  Otherwise, return NULL.  */
 
 void *
-hash_lookup (const Hash_table *table, const void *entry)
+recode_hash_lookup (const Hash_table *table, const void *entry)
 {
   struct hash_entry *bucket
     = table->bucket + table->hasher (entry, table->n_buckets);
@@ -244,7 +244,7 @@
 /* Return the first data in the table, or NULL if the table is empty.  */
 
 void *
-hash_get_first (const Hash_table *table)
+recode_hash_get_first (const Hash_table *table)
 {
   struct hash_entry *bucket;
 
@@ -263,7 +263,7 @@
    Return NULL if there is no more entries.  */
 
 void *
-hash_get_next (const Hash_table *table, const void *entry)
+recode_hash_get_next (const Hash_table *table, const void *entry)
 {
   struct hash_entry *bucket
     = table->bucket + table->hasher (entry, table->n_buckets);
@@ -290,7 +290,7 @@
    pointers.  */
 
 unsigned
-hash_get_entries (const Hash_table *table, void **buffer,
+recode_hash_get_entries (const Hash_table *table, void **buffer,
 		  unsigned buffer_size)
 {
   unsigned counter = 0;
@@ -322,7 +322,7 @@
    returns nonzero.  When it returns zero, the walking is interrupted.  */
 
 unsigned
-hash_do_for_each (const Hash_table *table, Hash_processor processor,
+recode_hash_do_for_each (const Hash_table *table, Hash_processor processor,
 		  void *processor_data)
 {
   unsigned counter = 0;
@@ -359,7 +359,7 @@
    may not be good for your application."  */
 
 unsigned
-hash_string (const char *string, unsigned n_buckets)
+recode_hash_string (const char *string, unsigned n_buckets)
 {
 # ifndef CHAR_BIT
 #  define CHAR_BIT 8
@@ -387,7 +387,7 @@
    (By the way, what happened to this excellent man?  Is he still alive?)  */
 
 unsigned
-hash_string (const char *string, unsigned n_buckets)
+recode_hash_string (const char *string, unsigned n_buckets)
 {
   unsigned value = 0;
 
@@ -438,7 +438,7 @@
 }
 
 void
-hash_reset_tuning (Hash_tuning *tuning)
+recode_hash_reset_tuning (Hash_tuning *tuning)
 {
   *tuning = default_tuning;
 }
@@ -500,7 +500,7 @@
    values.  */
 
 Hash_table *
-hash_initialize (unsigned candidate, const Hash_tuning *tuning,
+recode_hash_initialize (unsigned candidate, const Hash_tuning *tuning,
 		 Hash_hasher hasher, Hash_comparator comparator,
 		 Hash_data_freer data_freer)
 {
@@ -565,7 +565,7 @@
    affected entries.  */
 
 void
-hash_clear (Hash_table *table)
+recode_hash_clear (Hash_table *table)
 {
   struct hash_entry *bucket;
   struct hash_entry *cursor;
@@ -605,7 +605,7 @@
    entry.  */
 
 void
-hash_free (Hash_table *table)
+recode_hash_free (Hash_table *table)
 {
   struct hash_entry *bucket;
   struct hash_entry *cursor;
@@ -775,14 +775,14 @@
    exact number of buckets desired.  */
 
 bool
-hash_rehash (Hash_table *table, unsigned candidate)
+recode_hash_rehash (Hash_table *table, unsigned candidate)
 {
   Hash_table *new_table;
   struct hash_entry *bucket;
   struct hash_entry *cursor;
   struct hash_entry *next;
 
-  new_table = hash_initialize (candidate, table->tuning, table->hasher,
+  new_table = recode_hash_initialize (candidate, table->tuning, table->hasher,
 			       table->comparator, table->data_freer);
   if (new_table == NULL)
     return false;
@@ -861,7 +861,7 @@
    Return NULL if the storage required for insertion cannot be allocated.  */
 
 void *
-hash_insert (Hash_table *table, const void *entry)
+recode_hash_insert (Hash_table *table, const void *entry)
 {
   void *data;
   struct hash_entry *bucket;
@@ -918,7 +918,7 @@
 			     * tuning->growth_threshold));
 
 	  /* If the rehash fails, arrange to return NULL.  */
-	  if (!hash_rehash (table, candidate))
+	  if (!recode_hash_rehash (table, candidate))
 	    entry = NULL;
 	}
     }
@@ -931,7 +931,7 @@
    table, don't modify the table and return NULL.  */
 
 void *
-hash_delete (Hash_table *table, const void *entry)
+recode_hash_delete (Hash_table *table, const void *entry)
 {
   void *data;
   struct hash_entry *bucket;
@@ -963,7 +963,7 @@
 			      : (table->n_buckets * tuning->shrink_factor
 				 * tuning->growth_threshold));
 
-	      hash_rehash (table, candidate);
+	      recode_hash_rehash (table, candidate);
 	    }
 	}
     }
@@ -976,7 +976,7 @@
 #if TESTING
 
 void
-hash_print (const Hash_table *table)
+recode_hash_print (const Hash_table *table)
 {
   struct hash_entry *bucket;
 
diff -Nur recode-3.5d.orig/src/hash.h recode-3.5d/src/hash.h
--- recode-3.5d.orig/src/hash.h	Mon Mar 15 16:33:03 1999
+++ recode-3.5d/src/hash.h	Fri Mar 16 04:44:34 2001
@@ -91,30 +91,30 @@
 typedef struct hash_table Hash_table;
 
 /* Information and lookup.  */
-unsigned hash_get_n_buckets PARAMS ((const Hash_table *));
-unsigned hash_get_n_buckets_used PARAMS ((const Hash_table *));
-unsigned hash_get_n_entries PARAMS ((const Hash_table *));
-unsigned hash_get_max_bucket_length PARAMS ((const Hash_table *));
-bool hash_table_ok PARAMS ((const Hash_table *));
-void hash_print_statistics PARAMS ((const Hash_table *, FILE *));
-void *hash_lookup PARAMS ((const Hash_table *, const void *));
+unsigned recode_hash_get_n_buckets PARAMS ((const Hash_table *));
+unsigned recode_hash_get_n_buckets_used PARAMS ((const Hash_table *));
+unsigned recode_hash_get_n_entries PARAMS ((const Hash_table *));
+unsigned recode_hash_get_max_bucket_length PARAMS ((const Hash_table *));
+bool recode_hash_table_ok PARAMS ((const Hash_table *));
+void recode_hash_print_statistics PARAMS ((const Hash_table *, FILE *));
+void *recode_hash_lookup PARAMS ((const Hash_table *, const void *));
 
 /* Walking.  */
-void *hash_get_first PARAMS ((const Hash_table *));
-void *hash_get_next PARAMS ((const Hash_table *, const void *));
-unsigned hash_get_entries PARAMS ((const Hash_table *, void **, unsigned));
-unsigned hash_do_for_each PARAMS ((const Hash_table *, Hash_processor, void *));
+void *recode_hash_get_first PARAMS ((const Hash_table *));
+void *recode_hash_get_next PARAMS ((const Hash_table *, const void *));
+unsigned recode_hash_get_entries PARAMS ((const Hash_table *, void **, unsigned));
+unsigned recode_hash_do_for_each PARAMS ((const Hash_table *, Hash_processor, void *));
 
 /* Allocation and clean-up.  */
-unsigned hash_string PARAMS ((const char *, unsigned));
-void hash_reset_tuning PARAMS ((Hash_tuning *));
-Hash_table *hash_initialize PARAMS ((unsigned, const Hash_tuning *,
+unsigned recode_hash_string PARAMS ((const char *, unsigned));
+void recode_hash_reset_tuning PARAMS ((Hash_tuning *));
+Hash_table *recode_hash_initialize PARAMS ((unsigned, const Hash_tuning *,
 				     Hash_hasher, Hash_comparator,
 				     Hash_data_freer));
-void hash_clear PARAMS ((Hash_table *));
-void hash_free PARAMS ((Hash_table *));
+void recode_hash_clear PARAMS ((Hash_table *));
+void recode_hash_free PARAMS ((Hash_table *));
 
 /* Insertion and deletion.  */
-bool hash_rehash PARAMS ((Hash_table *, unsigned));
-void *hash_insert PARAMS ((Hash_table *, const void *));
-void *hash_delete PARAMS ((Hash_table *, const void *));
+bool recode_hash_rehash PARAMS ((Hash_table *, unsigned));
+void *recode_hash_insert PARAMS ((Hash_table *, const void *));
+void *recode_hash_delete PARAMS ((Hash_table *, const void *));
diff -Nur recode-3.5d.orig/src/html.c recode-3.5d/src/html.c
--- recode-3.5d.orig/src/html.c	Wed Jun 28 20:40:25 2000
+++ recode-3.5d/src/html.c	Fri Mar 16 04:44:34 2001
@@ -423,14 +423,14 @@
   if (before_options || after_options)
     return false;
 
-  table = hash_initialize (0, NULL, code_hash, code_compare, NULL);
+  table = recode_hash_initialize (0, NULL, code_hash, code_compare, NULL);
   if (!table)
     return false;
 
   for (cursor = translations; cursor->code; cursor++)
     if (cursor->flags & mask
 	&& (!request->diacritics_only || cursor->code > 128))
-      if (!hash_insert (table, cursor))
+      if (!recode_hash_insert (table, cursor))
 	return false;
 
   step->step_type = RECODE_UCS2_TO_STRING;
@@ -504,7 +504,7 @@
       struct ucs2_to_string *entry;
 
       lookup.code = value;
-      entry = hash_lookup (table, &lookup);
+      entry = recode_hash_lookup (table, &lookup);
       if (entry)
 	{
 	  const char *cursor = entry->string;
@@ -559,7 +559,7 @@
 {
   struct ucs2_to_string const *data = void_data;
 
-  return hash_string (data->string, table_size);
+  return recode_hash_string (data->string, table_size);
 }
 
 /*----------------------------------------.
@@ -592,14 +592,14 @@
   if (before_options || after_options)
     return false;
 
-  table = hash_initialize (0, NULL, string_hash, string_compare, NULL);
+  table = recode_hash_initialize (0, NULL, string_hash, string_compare, NULL);
   if (!table)
     return false;
 
   for (cursor = translations; cursor->code; cursor++)
     if (cursor->flags & mask
 	&& (!request->diacritics_only || cursor->code > 128))
-      if (!hash_insert (table, cursor))
+      if (!recode_hash_insert (table, cursor))
 	return false;
 
   step->step_type = RECODE_STRING_TO_UCS2;
@@ -801,7 +801,7 @@
 		struct ucs2_to_string *entry;
 
 		lookup.string = buffer;
-		entry = hash_lookup (subtask->step->step_table, &lookup);
+		entry = recode_hash_lookup (subtask->step->step_table, &lookup);
 		if (entry)
 		  {
 		    put_ucs2 (entry->code, subtask);
diff -Nur recode-3.5d.orig/src/names.c recode-3.5d/src/names.c
--- recode-3.5d.orig/src/names.c	Wed Jun 28 20:40:17 2000
+++ recode-3.5d/src/names.c	Fri Mar 16 04:44:34 2001
@@ -89,7 +89,7 @@
 {
   RECODE_CONST_ALIAS alias = void_alias;
 
-  return hash_string (alias->name, limit);
+  return recode_hash_string (alias->name, limit);
 }
 
 static bool
@@ -108,7 +108,7 @@
   outer->number_of_symbols = 0;
 
   outer->alias_table
-    = hash_initialize (800, NULL, alias_hasher, alias_comparator, NULL);
+    = recode_hash_initialize (800, NULL, alias_hasher, alias_comparator, NULL);
   if (!outer->alias_table)
     return false;
 
@@ -276,7 +276,7 @@
   lookup.name = name;
   if (!lookup.name)
     return NULL;
-  if (alias = hash_lookup (outer->alias_table, &lookup), alias)
+  if (alias = recode_hash_lookup (outer->alias_table, &lookup), alias)
     return alias;
 
   /* If we reach this point, find_type is necessarily one of SYMBOL_CREATE_*.
@@ -302,7 +302,7 @@
   alias->name = name;
   alias->symbol = symbol;
   alias->implied_surfaces = NULL;
-  if (!hash_insert (outer->alias_table, alias))
+  if (!recode_hash_insert (outer->alias_table, alias))
     {
       free (symbol);
       free (alias);
@@ -334,7 +334,7 @@
   symbol = alias->symbol;
 
   lookup.name = name;
-  if (alias = hash_lookup (outer->alias_table, &lookup), alias)
+  if (alias = recode_hash_lookup (outer->alias_table, &lookup), alias)
     {
       if (alias->symbol == symbol)
 	return alias;
@@ -350,7 +350,7 @@
   alias->name = name;
   alias->symbol = symbol;
   alias->implied_surfaces = NULL;
-  if (!hash_insert (outer->alias_table, alias))
+  if (!recode_hash_insert (outer->alias_table, alias))
     {
       free (alias);
       return NULL;
@@ -452,7 +452,7 @@
   struct make_argmatch_walk walk; /* wanderer's data */
 
 #if HASH_STATS
-  hash_print_statistics (outer->alias_table, stderr);
+  recode_hash_print_statistics (outer->alias_table, stderr);
 #endif
 
   /* It may happen that new modules are added only once all initialisation
@@ -474,7 +474,7 @@
   walk.outer = outer;
   walk.charset_counter = 0;
   walk.surface_counter = 0;
-  hash_do_for_each (outer->alias_table, make_argmatch_walker_1, &walk);
+  recode_hash_do_for_each (outer->alias_table, make_argmatch_walker_1, &walk);
 
   /* Allocate the argmatch and realname arrays, each with a NULL sentinel.  */
 
@@ -506,7 +506,7 @@
 
   walk.charset_counter = 0;
   walk.surface_counter = 0;
-  hash_do_for_each (outer->alias_table, make_argmatch_walker_2, &walk);
+  recode_hash_do_for_each (outer->alias_table, make_argmatch_walker_2, &walk);
 
   return true;
 }
@@ -661,7 +661,7 @@
   /* Count how many symbols we have.  */
 
   walk.number = 0;
-  hash_do_for_each (outer->alias_table, list_symbols_walker_1, &walk);
+  recode_hash_do_for_each (outer->alias_table, list_symbols_walker_1, &walk);
 
   /* Allocate a structure to hold them.  */
 
@@ -671,7 +671,7 @@
   /* Copy all symbols in it.  */
 
   walk.number = 0;
-  hash_do_for_each (outer->alias_table, list_symbols_walker_2, &walk);
+  recode_hash_do_for_each (outer->alias_table, list_symbols_walker_2, &walk);
 
   /* Sort it.  */
 
diff -Nur recode-3.5d.orig/src/recode.c recode-3.5d/src/recode.c
--- recode-3.5d.orig/src/recode.c	Wed Jun 28 20:40:20 2000
+++ recode-3.5d/src/recode.c	Fri Mar 16 04:45:01 2001
@@ -419,7 +419,7 @@
   if (before_options || after_options)
     return false;
 
-  table = hash_initialize (0, NULL,
+  table = recode_hash_initialize (0, NULL,
 			   ucs2_to_byte_hash, ucs2_to_byte_compare, NULL);
   if (!table)
     return false;
@@ -431,7 +431,7 @@
     {
       data[counter].code = code_to_ucs2 (step->after, counter);
       data[counter].byte = counter;
-      if (!hash_insert (table, data + counter))
+      if (!recode_hash_insert (table, data + counter))
 	return false;
     }
 
@@ -450,7 +450,7 @@
   while (get_ucs2 (&input_value, subtask))
     {
       lookup.code = input_value;
-      entry = hash_lookup (table, &lookup);
+      entry = recode_hash_lookup (table, &lookup);
       if (entry)
 	put_byte (entry->byte, subtask);
       else
diff -Nur recode-3.5d.orig/src/testdump.c recode-3.5d/src/testdump.c
--- recode-3.5d.orig/src/testdump.c	Wed Jun 28 20:40:13 2000
+++ recode-3.5d/src/testdump.c	Fri Mar 16 04:44:34 2001
@@ -152,7 +152,7 @@
   size_t size;			/* number of different characters */
   struct ucs2_to_count **array;	/* array into hash table items */
 
-  table = hash_initialize (0, NULL,
+  table = recode_hash_initialize (0, NULL,
 			   ucs2_to_count_hash, ucs2_to_count_compare, NULL);
   if (!table)
     return false;
@@ -168,7 +168,7 @@
 	struct ucs2_to_count *entry;
 
 	lookup.code = character;
-	entry = hash_lookup (table, &lookup);
+	entry = recode_hash_lookup (table, &lookup);
 	if (entry)
 	  entry->count++;
 	else
@@ -177,7 +177,7 @@
 	      return false;
 	    entry->code = character;
 	    entry->count = 1;
-	    if (!hash_insert (table, entry))
+	    if (!recode_hash_insert (table, entry))
 	      return false;
 	  }
       }
@@ -185,11 +185,11 @@
 
   /* Sort results.  */
 
-  size = hash_get_n_entries (table);
+  size = recode_hash_get_n_entries (table);
 
   if (!ALLOC (array, size, struct ucs2_to_count *))
     return false;
-  hash_get_entries (table, (void **) array, size);
+  recode_hash_get_entries (table, (void **) array, size);
 
   qsort (array, size, sizeof (struct ucs2_to_count *), compare_item);
 
@@ -255,7 +255,7 @@
     for (cursor = array; cursor < array + size; cursor++)
       free (*cursor);
   }
-  hash_free (table);
+  recode_hash_free (table);
 
   SUBTASK_RETURN (subtask);
 }
